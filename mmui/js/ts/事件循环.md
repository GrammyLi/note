渲染引擎和 JS 引擎，
js 和渲染是分开的。

JS 引擎处理 JavaScript 语言的一大特点就是单线程，同一个时间只能做一件事。为了协调事件、用户交互、脚本、UI 渲染和网络处理等行为，防止主线程的阻塞，才有 Event Loop。

js: 
1. 先会执行栈中的内容(先执行同步任务) 

2. 栈中的内容执行后执行微任务 
3. 微任务清空后再取出一个宏任务压入执行栈执行 
4. 再去执行微任务 （回到 2）
5. 然后在取宏任务清微任务这样不停的循环。

宏任务:setTimeout setInterval setImmediate  I/O postMessage

微任务:promise.then、resolve、mutationObersve、 async, await、process.nextTick ：每个类型队列结束后执行



三.前端使用异步的场景都有哪些?
1. 网络 ajax请求获取数据、图片加载等
2. 定时器
3. 回调函数：事件监听
4. promise

请描述eventloop(事件循环)的机制，可画图


个人总结

1.js代码从上到下一行一行执行，如果是同步代码，就放到Call Stack（调用栈）里执行

2.如果碰到异步代码，就先记录，等到合适的时机，就将他移动到Callback Queue(回调队列)

3.当同步代码执行完毕后，就会开启事件循环,事件循环会循环查找Callback Queue(回调队列)，如果有，则会移动到Call Stack(调用栈)里执行，然后继续循环查找(类似于永动机)



官方总结

事件循环（Event Loop）是JavaScript处理异步事件的一种核心机制，特别是在单线程环境中。其基本原理是，当遇到异步操作（如定时器、网络请求等）时，这些操作会被放入任务队列（Task Queue）中，而不会立即执行。一旦所有同步代码执行完毕，事件循环会开始从任务队列中取出任务并执行。

在JavaScript中，任务队列分为两种：宏队列（Macro Task Queue）和微队列（Micro Task Queue）。宏队列通常包括一些异步执行的代码，如setTimeout、setInterval、setImmediate和I/O操作等。而微队列则包括Promise的then回调函数、MutationObserver和queueMicrotask方法，这些任务的优先级要高于宏任务。

事件循环的工作流程大致如下：

1. 执行同步代码。
2. 检查微队列中是否有任务。如果有，则执行微队列中的所有任务，然后再检查宏队列。
3. 执行宏队列中的一个任务。
4. 再次检查微队列中是否有任务。如果有，则执行微队列中的所有任务。注意，这个过程会在每次执行完宏任务后都进行。
重复步骤3和4，直到宏队列和微队列都为空。
这种设计使得JavaScript可以在单线程下处理异步操作，避免了阻塞的情况，保证了程序的响应性和流畅性。同时，它也为开发者提供了一种处理异步事件和回调函数的统一方式。

事件循环的应用场景非常广泛，包括处理用户交互事件（如按钮点击、鼠标移动等）、异步请求、定时器、动画和页面渲染等。在这些场景中，事件循环都发挥着至关重要的作用，确保程序能够按照预期的方式运行



宏任务和微任务是什么
宏任务（Macro Task）
宏任务是指那些独立执行的任务，它们在主线程中按照一定顺序依次执行。每个宏任务执行完之后，浏览器都会进行UI渲染，然后再去检查微任务队列。

微任务（Micro Task）
微任务是在当前宏任务结束后、下一个宏任务开始前执行的小任务。微任务执行完之前，浏览器不会进行UI渲染。微任务一般用来处理需要紧随当前任务之后的操作。

宏任务和微任务的执行顺序
执行一个宏任务（如从事件队列中取一个）。
执行完这个宏任务后，检查微任务队列并全部执行，直到队列为空。
渲染UI。
再次循环执行宏任务中的步骤1。
宏任务和微任务的类型
宏任务包括：
setTimeout
setInterval
setImmediate (仅在IE和Node.js中支持)
I/O操作
UI渲染
事件触发

微任务包括：
Promise.then 或 Promise.catch 的回调函数
MutationObserver
process.nextTick (Node.js环境)




在浏览器中，一个Tab页可以看作一个进程，而渲染线程、HTTP请求线程和JS引擎线程则是协同工作的线程。


执行顺序是：
全局 js 代码 -> 全部微任务 -> 一个宏任务 -> 全部微任务 -> 一个宏任务 -> 全部微任务... 这样循环执行下去