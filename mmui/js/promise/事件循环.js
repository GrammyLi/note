1、请问 js 如何执行？
从前到后，一行一行执行
如果某一行执行报错 则停止下面代码的执行
先把同步代码执行完，在执行异步代码

2、请问 eventloop 过程？ (不考虑宏任务微任务 dom渲染)
同步代码、一行一行放在执行栈(call Stack)执行
遇到异步，会先"记录"下，等待时机（定时、网络请求等，WebApis）
时机到了，就移动到回调队列（callback Queue）
如果执行栈(call Stack)为空，即同步代码执行完，event loop开始工作
轮询查找回调队列（callback Queue），如果有则移动到执行栈(call Stack)执行
然后继续轮询查找（永动机一样）

3、完整的eventloop 过程？(考虑宏任务微任务 dom渲染)
同步代码、一行一行放在执行栈(call Stack)执行
遇到异步，会先"记录"下，等待时机（定时、网络请求等，WebApis）
时机到了，就移动到回调队列（callback Queue）
如果执行栈(call Stack)为空，即同步代码执行完 *
执行当前的微任务 **
尝试尝试dom渲染 ***
触发event loop、轮询查找回调队列（callback Queue），如果有则移动到执行栈(call Stack)执行 ****
然后继续轮询查找（永动机一样）




3、什么是宏任务macroTask 和微任务microTask？
宏任务：setTimeout、setInterval、Ajax、Dom事件
微任务：Promise、async/awaits
微任务执行时机要比宏任务要早

4、eventloop 和 Dom 渲染？
 js是单线程的，而且和Dom渲染共用一个线程，js执行的时候，得留一些时机供Dom渲染
每次call Stack清空(即每次轮询结束)，即同步任务执行完，都是dom重新渲染的机会，
dom结构如果有改变则重新渲染，然后再去出发下一次event loop

5、宏任务macroTask 和微任务microTask 的区别？
宏任务：Dom 渲染后触发 浏览器规定的
微任务：Dom 渲染前触发 ES6语法规定的

6、从eventloop 解释 为什么微任务执行时机要比宏任务要早？
当执行到Promise时 不会经过WebApis会把它放到 micro task queue  因为promise是ES规范不是W3C规范




事件循环（Event Loop）是 JavaScript 在单线程环境下处理异步任务的核心机制。其工作过程遵循特定的步骤，可以分为以下几个阶段：

事件循环的完整过程：
执行同步代码（同步任务）

JavaScript 引擎从上到下执行同步代码，一行一行地将同步代码放入 执行栈（Call Stack）中。
执行栈中的任务会被按顺序执行，直到栈中的任务为空为止。
遇到异步代码时，交给 Web APIs 处理

当 JavaScript 遇到异步操作（例如 setTimeout、Promise、AJAX 请求等），这些任务不会立即执行，而是交给浏览器的 Web APIs（如定时器、网络请求等）处理。
异步操作会被“记录”下来，并在适当时机将回调函数放入 回调队列（Callback Queue）中等待执行。
执行栈清空后，执行微任务队列中的任务

微任务 是优先级较高的异步任务，它们包括 Promise 的回调函数、MutationObserver 等。微任务队列中的任务会在每次从执行栈退出后、执行下一个宏任务之前执行。
在执行栈为空时，事件循环会立即开始执行微任务队列中的所有任务，直到队列为空。
尝试 DOM 渲染（浏览器渲染阶段）

微任务执行完之后，浏览器会尽可能地进行 DOM 渲染。这通常涉及将 DOM 更新反映到页面上，进行页面重绘（Repaint）和重排（Reflow）。
如果有 DOM 更新，浏览器会计算布局并绘制页面。这个阶段通常是浏览器自己管理的，不能直接在 JavaScript 代码中控制，但它是事件循环的一部分。
轮询回调队列（宏任务队列）

事件循环会检查 回调队列（Callback Queue），查找是否有宏任务（如 setTimeout、setInterval 等）需要执行。
如果有宏任务，事件循环会将回调队列中的第一个宏任务移到 执行栈 中，开始执行该宏任务。
继续轮询

完成当前的宏任务后，事件循环再次返回步骤 3，检查微任务队列，执行所有微任务。
然后再次尝试渲染 DOM，最后执行下一个宏任务。这一过程会持续进行，形成类似“永动机”的循环。
事件循环的每一轮（基本步骤）：
执行同步代码（进入执行栈）；
处理微任务（执行所有微任务）；
DOM 渲染（如果需要，执行浏览器的渲染）；
执行宏任务（从宏任务队列中取出任务并执行）；
继续检查微任务队列（如果有微任务，立即执行，直到队列清空）；
继续执行宏任务，然后循环这个过程。
微任务和宏任务的区别：
宏任务：包括 setTimeout、setInterval、I/O 操作、AJAX 请求、事件回调等。
微任务：包括 Promise 的回调、MutationObserver 等。
事件循环的关键点：
优先执行微任务：事件循环会在每次执行宏任务之前先执行微任务队列中的任务。
DOM 渲染时机：通常是在微任务执行完后，浏览器才会进行 DOM 渲染，确保页面更新的稳定性和性能。
宏任务和微任务交替执行：事件循环首先执行微任务，之后执行宏任务，然后再执行微任务，如此循环。
总结： 事件循环的循环过程可以简单表示为：

执行同步代码；
执行所有微任务；
执行 DOM 渲染（浏览器的渲染阶段）；
执行一个宏任务；
继续轮询，直到没有任务。
