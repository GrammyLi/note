## http1.0 

主要使用 header 里的 If-Modified-Since（协商缓存请求标识）, Expires（强缓存） 来做为缓存判断的标准
支持get post 方法

## http1.1 

cache Control、 Etag、If-None-Match 等更多可供选择的缓存头来控制缓存策略

支持长链接Connection: keep-alive, 一次TCP链接多次请求

断点续传，传完之后返回状态码206

支持新的方法 PUT、HEAD、OPTIONS 等，可用于restful api

## http2.0

可以压缩header减少体积
新的二进制格式(Binary Format)：2.0 基于二进制解析，1.x 基于文本解析

多路复用: 一个request对应一个id，这样一个连接上可以有多个request（类似CPU时间片）一次tcp连接中可以多个http并行请求

降低了慢启动的影响（只有一个链接，越来越快）
服务端推送
需要主动配置（nginx: http2_push /style.css;


其他介绍： http2 中多路复用
在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手和 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive，解决了多次连接的问题，但是依然有两个效率上的问题，一是串行的文件传输，二是连接数过多导致的性能问题。

HTTP/2 的多路复用就是为了解决上述的两个性能问题。

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。




性能提升
多路复用：HTTP/2 允许在一个 TCP 连接上同时发送多个请求和响应，这和 HTTP/1.1 每次只能发送一个请求（响应）的模式不同。例如，在加载一个网页时，多个资源（如脚本、样式表、图片等）可以同时通过一个连接传输，不用像 HTTP/1.1 那样排队等待，大大提高了资源加载速度，减少了页面的加载时间。
头部压缩：HTTP/2 使用 HPACK 算法对请求和响应头进行压缩。在 HTTP/1.1 中，请求头和响应头往往包含大量重复的信息，如用户代理、Cookie 等。HPACK 算法通过对这些头部信息进行索引和编码，能显著减少头部数据的大小，节省网络带宽，提高传输效率

安全性增强
HTTP/2 通常是在 TLS（Transport Layer Security）协议之上运行，这就保证了数据传输的安全性。TLS 加密可以防止数据在传输过程中被窃取、篡改等，有助于保护用户的隐私和网站的安全。



HTTP/1.1 支持多个请求同时发送，但是它存在队头阻塞（Head - of - Line Blocking）问题。
在 HTTP/1.1 中，虽然可以在一个 TCP 连接上同时发送多个请求，但是对于响应的接收是有顺序要求的。一个请求的响应如果没有接收完，后面的请求响应就会被阻塞。例如，浏览器同时发送了请求 A 和请求 B，服务器先开始处理请求 A，在请求 A 的响应没有完全返回之前，请求 B 的响应即使已经准备好了也不能被发送给浏览器，必须等请求 A 的全部响应接收完后，请求 B 的响应才能开始接收。