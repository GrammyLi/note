### **1. HTTP/1.1 与 HTTP/2 的多路复用是什么？**

**多路复用**（Multiplexing）是 HTTP/2 的一项核心特性，它允许在单个 TCP 连接中并行发送和接收多个 HTTP 请求和响应，而不需要为每个请求建立独立的连接，从而提高了传输效率并减少了网络延迟。

------

#### **HTTP/1.1 的特性及问题：**

1. **TCP 连接的使用**：
   - 默认情况下，HTTP/1.1 使用短连接（每个请求都会建立一个新的 TCP 连接）。
   - 为了提升性能，支持 **持久连接**（`Keep-Alive`），多个 HTTP 请求可以复用同一个 TCP 连接，但同一时间只能处理一个请求。
2. **队头阻塞（Head-of-Line Blocking）：**
   - 在一个连接中，多个请求被按顺序依次处理。
   - 如果一个请求被阻塞（如响应数据较慢），后续请求都无法处理。
3. **解决方法的局限性**：
   - 浏览器会为同一个域名并发建立多个 TCP 连接（通常为 6-8 个），但过多的连接会增加系统资源消耗（如 TCP 握手、慢启动等）。

------

#### **HTTP/2 的改进：**

1. **多路复用（Multiplexing）：**

   - 在单个 TCP 连接中，同时发送多个请求，并行接收多个响应。
   - 每个请求和响应被拆分为多个帧（frame），通过流 ID 标识归属，相互独立，互不影响。
   - 消除了 HTTP/1.1 的队头阻塞问题。

   **例子：** 假设你请求了 5 个资源（图片、CSS、JS 等），HTTP/1.1 必须按顺序完成这些请求，而 HTTP/2 可以在一个连接中同时发送和接收这 5 个请求。

2. **头部压缩：**

   - HTTP/2 使用 HPACK 压缩协议，对 HTTP 头部进行压缩，减少冗余数据传输。
   - 比如多个请求可能会有相同的 `User-Agent`，在 HTTP/1.1 中会重复发送，但在 HTTP/2 中只发送一次。

3. **二进制帧（Binary Frame）：**

   - HTTP/2 使用二进制格式传输数据，替代了 HTTP/1.1 的文本格式，解析效率更高。
   - 数据被拆分为帧，通过流 ID 组装，支持更灵活的数据传输。

4. **优先级和流量控制：**

   - HTTP/2 支持为不同的流分配优先级，重要的数据流会被优先处理。
   - 同时支持流量控制，确保低优先级的流不会占用过多带宽。

------

#### **HTTP/1.1 与 HTTP/2 的对比：**

| **特性**       | **HTTP/1.1**                  | **HTTP/2**                    |
| -------------- | ----------------------------- | ----------------------------- |
| **连接复用**   | 一个 TCP 连接只能处理一个请求 | 一个 TCP 连接支持并行多个请求 |
| **队头阻塞**   | 存在队头阻塞                  | 消除队头阻塞                  |
| **请求和响应** | 请求和响应是顺序的            | 请求和响应是并行的            |
| **数据格式**   | 文本格式（明文）              | 二进制格式                    |
| **头部压缩**   | 无（头部冗余）                | 支持头部压缩（HPACK）         |
| **优先级控制** | 不支持                        | 支持优先级和流量控制          |

------

#### **多路复用的优点：**

1. **性能提升**：
   - 避免了队头阻塞，多个请求可以同时处理，减少了请求的等待时间。
2. **减少 TCP 连接**：
   - 同一时间只需一个 TCP 连接，避免了 HTTP/1.1 中多连接导致的系统资源开销（如连接建立、慢启动等）。
3. **带宽利用率更高**：
   - 数据以二进制形式传输，头部压缩减少了传输的数据量，进一步提高带宽利用率。

------

#### **注意事项：**

- **队头阻塞依然存在：**
  - HTTP/2 在应用层消除了队头阻塞，但在传输层（TCP）仍可能存在队头阻塞（如 TCP 丢包导致整个连接阻塞）。
  - HTTP/3 使用基于 UDP 的 QUIC 协议，从根本上解决了传输层的队头阻塞。
- **浏览器支持：**
  - HTTP/2 已被现代浏览器广泛支持，但需要服务端也支持 HTTP/2。

------

#### **总结**

- **HTTP/1.1** 的性能瓶颈主要来源于队头阻塞和多连接开销。
- **HTTP/2** 通过多路复用、头部压缩和二进制帧等技术，显著提升了传输效率，是 Web 性能优化的重要工具。

------

### 2. **原型继承的实现**

JavaScript 的原型继承通过 `prototype` 和 `__proto__` 实现。具体方法如下：

- **构造函数方式**：

  ```javascript
  function Parent(name) {
    this.name = name;
  }
  Parent.prototype.sayHello = function () {
    console.log(`Hello, ${this.name}`);
  };
  
  function Child(name) {
    Parent.call(this, name); // 继承属性
  }
  Child.prototype = Object.create(Parent.prototype); // 继承方法
  Child.prototype.constructor = Child; // 修复 constructor
  ```

- **ES6 Class 继承**：

  ```javascript
  class Parent {
    constructor(name) {
      this.name = name;
    }
    sayHello() {
      console.log(`Hello, ${this.name}`);
    }
  }
  
  class Child extends Parent {
    constructor(name) {
      super(name); // 继承父类属性
    }
  }
  ```

------

### 3. **`this` 指向**

`this` 的指向由函数调用的方式决定：

1. **普通函数调用**：`this` 指向全局对象（在严格模式下为 `undefined`）。
2. **对象调用**：`this` 指向调用该方法的对象。
3. **构造函数调用**：`this` 指向新创建的实例对象。
4. **箭头函数**：箭头函数没有自己的 `this`，它的 `this` 继承自定义时的上下文。

------

### 4. **图片预加载**

图片预加载用于在用户真正需要查看图片之前，将图片加载到内存中，提升用户体验。

**方法**：

1. 使用 `Image` 对象：

   ```javascript
   const img = new Image();
   img.src = "image-url";
   ```

2. 将图片隐藏到页面外：

   ```html
   <img src="image-url" style="display:none;" />
   ```

------

### 5. **React 中 Redux 的数据流**

- Redux 的数据流是单向的：

  Action -> Reducer -> Store -> View。

  1. **Action**：描述要执行的操作。
  2. **Reducer**：纯函数，根据 Action 更新状态。
  3. **Store**：保存应用的全局状态。
  4. **View**：根据 Store 渲染 UI。

------

### 6. **Context 和 Redux 的比较**

- **Context**：
  - React 提供的原生 API，用于在组件树中共享状态。
  - 适用于简单的全局状态管理。
- **Redux**：
  - 更复杂和完整的状态管理工具，支持中间件（如 `redux-thunk`、`redux-saga`）。
  - 更适合复杂应用中的全局状态管理。

------

### 7. **`useState` 和 `useReducer` 的区别**

- **`useState`**：
  - 适用于管理简单的状态。
  - 每次状态更新时，需要通过直接设置值来更新状态。
- **`useReducer`**：
  - 适用于管理复杂的状态逻辑。
  - 通过 Reducer 函数来定义状态的更新逻辑。

------

### 8. **二分查找的时间复杂度及流程**

**时间复杂度**：O(log n)

**流程**：

1. 确定数组的中间元素。
2. 比较目标值与中间值：
   - 如果目标值小于中间值，则查找左半部分。
   - 如果目标值大于中间值，则查找右半部分。
3. 重复上述步骤，直到找到目标值或搜索范围为空。

------

### 9. **`background` 的 `cover` 和 `contain` 的区别**

- **`cover`**：背景图片会保持比例缩放，以覆盖整个容器（可能会裁剪图片）。
- **`contain`**：背景图片会保持比例缩放，以完全包含在容器内（不会裁剪图片）。

------

### 10. **物理像素和逻辑像素的区别**

- **物理像素**：设备屏幕上的真实像素点（如 Retina 屏幕的物理像素密度更高）。
- **逻辑像素**：CSS 中定义的像素，开发者操作的是逻辑像素。

**关系**： `物理像素 = 逻辑像素 * 设备像素比（DPR）`

------

### 11. **`rem` 是什么**

`rem` 是 CSS 的一种长度单位，表示相对于根元素（HTML）的字体大小。

例如：

```css
html { font-size: 16px; }
div { width: 2rem; } /* 等于 32px */
```

------

### 12. **React 的合成事件和原生事件执行顺序**

React 的 **合成事件** 会先于 **原生事件** 执行，原因是 React 的事件系统是基于合成事件实现的，用于跨浏览器的兼容和性能优化。

执行顺序：

1. React 合成事件。
2. 原生事件。

------

### 13. **React 的 Diff**

React 的 Diff 算法通过对虚拟 DOM 的树结构进行比较，找出前后变化，最小化 DOM 操作。

**优化策略**：

1. 同层比较。
2. 使用 `key` 优化列表比较。

------

### 14. **React 项目性能优化**

1. **减少重新渲染**：
   - 使用 `React.memo`、`useCallback`、`useMemo`。
2. **代码分割**：
   - 使用 `React.lazy` 和 `Suspense` 实现按需加载。
3. **长列表优化**：
   - 使用虚拟滚动库（如 `react-window`）。
4. **避免不必要的重绘**：
   - 使用 `shouldComponentUpdate`。

------

### 15. **Webpack 中 Loader 和 Plugin 的区别**

- **Loader**：用于文件转换，比如编译 ES6、处理图片等。
- **Plugin**：用于扩展 Webpack 的功能，如代码压缩、生成 HTML 文件等。

------

### 16. **前端项目性能优化**

1. **减少资源体积**：压缩 JavaScript、CSS 和图片。
2. **延迟加载**：使用懒加载技术。
3. **缓存策略**：设置浏览器缓存。
4. **CDN 加速**：静态资源使用 CDN。
5. **长列表优化**：使用虚拟滚动。