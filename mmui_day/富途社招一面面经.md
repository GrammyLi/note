

### 1. **从输入 URL 到页面加载完毕的过程（及优化）**

- **过程**:
  1. **DNS 查询**：浏览器解析 URL，转换为 IP 地址。
  2. **TCP 连接**：通过三次握手与服务器建立连接。
  3. **发送 HTTP 请求**：浏览器通过 TCP 连接发送 HTTP 请求。
  4. **服务器响应**：服务器处理请求并返回响应数据。
  5. **页面渲染**：浏览器接收到 HTML 后开始构建 DOM 树，解析 CSS，执行 JS，并进行页面渲染。
- **优化方法**：
  - **DNS 解析优化**：可以使用 DNS 缓存，或者减少 DNS 查询次数。
  - **TCP 连接优化**：使用 HTTP/2，可以减少连接次数，启用长连接和多路复用。
  - **资源压缩**：对 CSS、JS 资源进行压缩、合并，减少请求次数。
  - **懒加载**：延迟加载非关键资源，减少页面首次加载的资源量。
  - **CDN**：使用内容分发网络（CDN）加速资源加载。
  - **缓存策略**：使用合适的缓存策略，如 HTTP 强缓存、协商缓存。
- **懒加载**：是指对于一些不必要的资源（如图片、脚本等）在初次渲染时不进行加载，等到资源真正需要显示时再进行加载。优化了首屏加载的速度，提高了用户体验。

------

### 2. **Vue 源码和双向绑定原理**

- **Vue 双向绑定原理**：Vue 的双向绑定基于 **数据劫持** 和 **发布-订阅模式**：
  - **数据劫持**：Vue 使用 `Object.defineProperty()` 或 Vue 3 中的 `Proxy` 来劫持对象的 getter 和 setter 操作，从而追踪数据的变化。
  - **发布-订阅模式**：当数据发生变化时，通知订阅者（即组件）重新渲染视图。
- **优化点**：
  - 对于大量数据绑定，Vue 会对属性进行懒加载和优化，例如 Vue 3 使用的 `Proxy` 提升了性能，并减少了性能瓶颈。

------

### 3. **跨域问题及解决方案**

- **跨域**：跨域是指浏览器的同源策略（Same-Origin Policy）限制了不同源（域名、协议、端口不同）的页面相互访问数据。

- 解决方案

  ：

  1. **CORS（跨源资源共享）**：通过设置 HTTP 请求头 `Access-Control-Allow-Origin` 等来允许跨域请求。
  2. **JSONP**：通过 `<script>` 标签的跨域特性来绕过浏览器的同源策略。
  3. **Proxy（代理）**：通过服务器代理转发请求，使得请求看起来是同源的。
  4. **WebSocket**：WebSocket 协议不受同源策略的限制，适用于实时通信。

- **Proxy 原理**：代理服务器充当中介，前端请求资源时，先发送请求到代理服务器，再由代理服务器转发到目标服务器，最后返回给客户端。

------

### 4. **事件循环机制**

- 事件循环

  ：JavaScript 的执行是单线程的，但为了处理异步操作，JavaScript 使用了事件循环机制。事件循环有两个重要的任务队列：

  - **宏任务**（Macrotasks）：包括整体的脚本执行、setTimeout、setInterval 等。
  - **微任务**（Microtasks）：包括 Promise 回调、MutationObserver 等。

- 为什么区分宏任务和微任务

  ：

  - 微任务的优先级高于宏任务，事件循环会先执行完微任务队列中的任务再执行下一个宏任务。因此，理解事件循环可以帮助我们优化异步操作和任务调度，避免出现预期之外的延迟或性能瓶颈。

------

### 5. **this 指向**

- **改变 `this` 指向**：
  1. **`call`**：调用函数并指定 `this`，`call` 会立即执行函数。
  2. **`apply`**：与 `call` 类似，但 `apply` 接收一个数组作为参数。
  3. **`bind`**：返回一个新函数，新的函数会将 `this` 绑定到指定对象，并且可以传入参数，直到调用时才会执行。
- **区别**：
  - **`call` 和 `apply`**: 主要区别在于参数传递的方式。`call` 使用逗号分隔的参数，`apply` 使用数组传递。
  - **`bind`**: 返回一个新函数，不立即执行，而是返回一个带有指定 `this` 的函数。

------

### 6. **手写数组去重**

- **常见解法**：
  1. **使用 Set**：`[...new Set(arr)]`
  2. **使用对象键值**：遍历数组，用对象的键来去重。
- **优化**：
  - 利用 `Set` 是最简洁、最常见的去重方法，时间复杂度为 O(n)。
  - 对于复杂的数据结构（如对象数组），可以通过 `JSON.stringify()` 和 `Map` 来进行深度去重。

------

### 7. **浏览器缓存**

- **强缓存**：指的是浏览器根据资源的 HTTP 响应头中的 `Cache-Control` 或 `Expires` 来决定是否从缓存中获取资源。
- **协商缓存**：当强缓存失效后，浏览器会发送请求给服务器，通过 `Last-Modified` 或 `ETag` 与服务器进行协商，检查资源是否有更新。如果资源没有更新，服务器返回 `304 Not Modified` 状态，避免重新下载。
- **补充**：
  - **浏览器缓存的策略优化**：合理设置 `Cache-Control`、`Expires`，使用版本号或哈希值防止缓存错乱。

------

### 8. **项目中的困难**

- Vue 白屏问题

  ：可能是由于前端加载资源失败或者后端返回错误的重定向。解决前端白屏问题时，通常首先检查：

  1. **网络请求**：是否资源加载失败？
  2. **JavaScript 错误**：检查是否有错误的脚本或组件加载失败。
  3. **组件渲染**：检查 Vue 的生命周期钩子，是否是某个生命周期钩子中的错误导致白屏。
  4. **路由配置**：检查路由是否正确配置，是否发生了重定向错误。

------

### 9. **TCP 三次握手**

- **三次握手**：客户端与服务器建立连接时，需要进行三次握手来确保连接的可靠性。
  1. **SYN**：客户端发送一个 SYN（同步）请求，告诉服务器它准备建立连接。
  2. **SYN-ACK**：服务器回应客户端的请求，发送一个 SYN-ACK 包，表示同意建立连接。
  3. **ACK**：客户端再次发送一个 ACK 包，确认服务器的响应，连接建立完成。
- **为什么三次握手**：
  - 防止已经失效的连接请求被服务器接受。如果没有三次握手，服务器可能会错误地认为客户端发送过来的请求是有效的，而这些请求可能已经超时或丢失。

------

### 10. **Vue 生命周期**

- `created`

   和 

  `mounted`

  ：

  - **`created`**：组件实例化之后，数据观测和事件配置已经完成，但 DOM 还没有生成。通常用于异步请求数据。
  - **`mounted`**：DOM 已经渲染完成，可以进行 DOM 操作。一般用于初始化一些依赖 DOM 的操作。

------

### 11. **computed 和 watch 区别**

- **`computed`**：
  - 用于 **计算属性**，会根据依赖的响应式数据进行缓存，只有在依赖的数据发生变化时才会重新计算。
  - **适用场景**：当你需要根据现有数据派生出新的数据时。
- **`watch`**：
  - 用于 **观察数据变化**，当数据发生变化时会执行一个回调函数。
  - **适用场景**：当你需要执行一些副作用操作（例如异步请求、数据持久化等）时。

------

### 12. **平时如何学习技术**

- 方法

  ：

  - 看技术博客和文章，保持对前端和后端技术的关注。
  - 阅读源码，尤其是框架（如 Vue、React）的源码，理解其设计理念和实现原理。
  - 动手做项目，实际操作是巩固学习的最佳方法。

------

通过这些问题，面试官测试了你的 **基础知识**、**项目经验** 和 **解决问题的能力**，特别是在 **前端开发** 和 **Vue** 相关的技术栈上。





### 题目来源：

作者：牛客722201516号 

链接：https://www.nowcoder.com/discuss/353157667629768704?sourceSSR=search 

来源：牛客网