## 说一下浏览器缓存

浏览器缓存分为强缓存和协商缓存，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。
控制强缓存的字段有：Expires 和 Cache-Control
控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高

## cookie 与 session 的区别

Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。

## 浏览器如何做到 session 的功能的。

原理
当用户第一次访问网站时，服务器会创建一个唯一的会话标识符（Session ID），这个标识符通常是一个随机的字符串。服务器会通过设置 Set - Cookie 响应头，将这个 Session ID 发送给浏览器。例如，服务器可能会发送一个类似 Set - Cookie: sessionid=abc123; Path=/; HttpOnly 的响应头。

浏览器收到这个响应头后，会将 Cookie（包含 Session ID）存储在本地。之后，浏览器在每次向同一域名发送请求时，都会在请求头中自动带上这个 Cookie。例如，请求头中会有 Cookie: sessionid = abc123。

服务器收到请求后，就可以根据这个 Session ID 来识别用户，从服务器端存储的会话数据中找到与该 Session ID 对应的用户信息，如用户登录状态、购物车内容等，从而实现了会话（Session）功能

应用场景和优势
这种方式广泛应用于需要用户登录的网站。比如电商网站，用户登录后，服务器可以通过 Session ID 关联用户的购物车信息。即使用户在网站的不同页面跳转或者添加商品到购物车，服务器都能通过浏览器发送的 Session ID 来识别用户，保证购物体验的连贯性。它的优势在于简单易用，能够方便地在服务器和浏览器之间传递用户身份信息。

可能出现的问题及解决方法：
安全性问题是 Cookie 方式的一个主要关注点。如果 Cookie 被窃取，攻击者可能会冒用用户身份。为了解决这个问题，服务器可以设置 HttpOnly 属性，这样 JavaScript 就无法访问 Cookie，减少了跨站脚本攻击（XSS）的风险。同时，还可以使用安全的传输协议（如 HTTPS）来加密数据，防止 Cookie 在传输过程中被窃取。另外，Cookie 的大小是有限制的（通常为 4KB 左右），如果存储的会话信息过多，可能会超出限制。此时可以考虑将部分数据存储在服务器端，只在 Cookie 中存储关键的 Session ID

## 解释一下：csrf 和 xss

XSS：恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。

CSRF：CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。

## 跨域的处理方案有哪些

常用的：jsonp、CORS、nginx 代理，完整的大概是九种，可见：九种跨域方式实现原理（完整版）

https://juejin.cn/post/6844903767226351623

## 对于 CORS ，Get 和 POST 有区别吗？

GET 传输数据的方式和限制：GET 请求的数据是通过 URL 的查询字符串（?后面的部分）来传递的。这种方式数据量有限制，因为 URL 长度有一定限制（不同浏览器和服务器的限制可能不同，但一般来说不能过长）。并且数据会在 URL 中明文显示，所以不适合传输敏感信息。在 CORS 场景下，虽然 GET 请求相对简单，但也要注意数据的安全性，因为数据在传输过程中可能被截取。

POST 传输数据的特点和安全性考虑：POST 请求可以在请求体中传输数据，数据量通常没有像 GET 那样严格的限制（受服务器配置等因素影响）。而且 POST 请求可以用于传输更复杂和敏感的数据，因为数据不是直接暴露在 URL 中。在 CORS 中，对于 POST 请求，特别是涉及敏感数据的 POST 请求，服务器需要更加严格地验证和处理，包括检查请求来源是否被允许（通过 Access - Control -Allow - Origin 等头部）和验证请求中的数据

## 了解 HTTPS 的过程吗？

客户端发起请求：客户端首先向服务器发起 HTTPS 请求，在这之前会先建立 TCP 连接，作为后续通信的基础。

协商加密算法：客户端发送 “Client Hello” 消息，告知服务器自己支持的加密算法等信息，服务器收到后回应 “Server Hello” 消息，选择双方都支持的加密算法，并把自己的 SSL 证书发给客户端。

客户端验证证书：客户端收到证书后，会验证证书的有效性、签名合法性以及是否被吊销等情况。

生成并交换会话密钥：若证书验证通过，客户端生成对称会话密钥，用服务器证书中的公钥加密后发给服务器，服务器用私钥解密获取该密钥。

加密传输数据：之后双方就使用这个会话密钥对要传输的数据进行加密和解密，从而实现安全的数据传输

## webpack 如何做性能优化

webpack 做性能优化主要是考虑打包体积和打包速度。

体积分析用 webpack-bundle-analyzer 插件，速度分析用：speed-measure-webpack-plugin 插件。

## es module 和 commonjs 的区别

考察 ES6 模块和 CommonJS 模块 的区别。
关键点：

1. 前者是值的引用，后者是值的拷贝。
2. 前者编译时输出接口，后者运行时加载

https://juejin.cn/post/6844903576309858318

## react 里如何做动态加载

React.lazy ，另外通过 webpack 的动态加载：import() 和 ensure.require

## 动态加载的原理是啥，就是 webpack 编译出来的代码

讲道理 webpack 动态加载就两种方式：import()和 require.ensure，不过他们实现原理是相同的。
我觉得这道题的重点在于动态的创建 script 标签，以及通过 jsonp 去请求 chunk

。

 
作者：桃翁
链接：https://juejin.cn/post/6844904161830502407
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
